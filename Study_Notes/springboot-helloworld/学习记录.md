# springboot 学习记录

> 注意：Springboot注解`@SpringBootApplication`默认扫描当前类的同包或子包下的类。因此位置一定要放对！！否则访问地址会报404错误！！

## 起步依赖

1. idea搭建springboot项目依赖的是 [start.spring.io](https://start.spring.io) 需要网络
2. springboot帮我们配置好了所需依赖的版本，这样我们不用担心版本冲突的问题
3. **JDK8**对应的major version是**52**，**JDK17**对应的major version是**61**
4. `@RestController`相当于是`@Controller`和`@ResponseBody`的组合,也就是说, `@RestController`标记的类其方法返回值不会被当作视图来解析。而传统的`@Controller`注解，其返回值会被当作视图经过视图解析器来解析。

## 配置文件

springboot是**基于约定**的框架。想要替换其默认配置，通过`application.properties`或者`application.yaml`来进行配置

- properties:

```properties
server.port=8080
```

- yaml/yml: ( 冒号`:`和值`8080`之间**有空格** )
  
```yaml
server:
  port: 8080  #有空格
```

### springboot配置文件优先级

> springboot加载配置文件**有优先级**： 如果properties，yml，yaml三个配置文件在根目录中同时存在，那么*对于重复的配置部分*，**springboot会优先加载properties中的配置，其次是yml，最后是yaml。**

## yaml

yaml全程是 yaml ain't markup language。

yaml**以数据为中心**，能更直观的被人类理解，比传统xml方式更简洁。

### yaml语法

1. 大小写敏感
2. 数据值前必须有空格
3. 使用缩进表示层级关系
4. `#`表示注释
5. 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

### yaml数据格式

- 对象（map）
```yaml
person:
  name: zhangsan

person: {name: zhangsan}
```

- 数组
```yaml
address:
  - beijing
  - shanghai

address: [beijing,shanghai]
```

- 纯量
```yaml
msg1: "hello \n world"  #会识别转义字符，\n将被解析为空格
msg2: 'hello \n world'  #不会识别转义字符，\n将原样输出
```

### yaml参数引用

```yaml
name: lisi

person: 
  name: ${name}  #引用上值
```

## 读取配置内容

1. @Value
```java
@Value("${name}")
private String name;
```
2. Environment
```java
@Resource   //基于名称注入  @Autowired 基于类型注入
private Environment env;

System.out.println(env.getProperty("person.name"));
System.out.println(env.getProperty("address[0]"));
```
3. @ConfigurationProperties

创建一个类来接收配置文件中的属性

使用`@ConfigurationProperties`注解来接收配置文件中的属性

使用prefix属性来指定属性前缀，防止错误的注入

```java
@Component
@ConfigurationProperties(prefix = "person")
public class Person {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
```yaml
server:
  port: 8080

name: abc

person:
  name: zhangsan
  age: 20

person2: {name: zhangsan, age: 20}

address: [beijing, shanghai]

msg: "hello \n word!"
msg2: 'hello \n word!'

```

## profiles

profiles属性可以指定当前配置文件生效的环境，在实际开发中通常一个springboot应用会在多个场景下使用，比如开发场景，生产场景，测试场景等。这些场景的配置文件不尽相同。如果每次都手动来更改配置文件，过于繁琐。因此，springboot 的 profiles 属性可以帮我们快速切换配置文件。

### 1. 多profile文件方式

假设现在有两个配置文件，`application-dev.yaml`和`application-pro.yaml`，分别对应开发环境和生产环境。想要快速切换这两个配置文件，只需要在主配置文件`application.yaml`中声明 profiles 属性即可

![](img/Snipaste_2023-10-31_08-31-02.png)

```yaml
spring:
  profiles:
    active: pro
```
### 2. yml多文档方式

多个配置文件方式写起来比较麻烦，我们可以通过一个application.yml文件来进行配置。只需要使用 `---` 来对不同环境下的配置进行分割即可。

```yaml

spring:
  profiles:
    active: test   # 设置激活的配置
---
server:
  port: 8080
spring:
  profiles: dev
---
server:
  port: 8081
spring:
  profiles: test
---
server:
  port: 8082
spring:
  profiles: pro
---

```

### 3. 外部参数方式

#### 1. 通过虚拟机选项 vm-options 来进行配置

这种方式会覆盖掉application.yaml中的配置

![](img/Snipaste_2023-10-31_08-43-30.png)

#### 2. 通过命令行参数进行配置

在运行项目的jar包时加上`--spring.profiles.active=dev`，可以指定当前激活的配置文件。

## 内部配置加载顺序
    
springboot启动时会从以下位置加载配置文件：

1. `file: ../config/` 当前项目下的/config目录
2. `file: ../` 当前项目的根目录
3. `classpath:/config/` classpath的/config目录
4. `classpath:/` classpath根目录

以上四个位置的配置文件都会被读取，高优先级的文件配置会覆盖低优先级的文件配置

## thymeleaf

thymeleaf是一个xml/xhtml/html5的模板引擎，可以作为springmvc的视图技术来使用。

```xml
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>分页信息展示</title>
</head>
<body>
    <table>
        <tr>
            <td>部门编号</td>
            <td>部门名称</td>
            <td>部门地址</td>
        </tr>
        <tr th:each="dept : ${pageInfo.list}">
            <td th:text="${dept.deptno}"></td>
            <td th:text="${dept.dname}"></td>
            <td th:text="${dept.loc}"></td>
        </tr>
    </table>
    <div th:if="!${pageInfo.isFirstPage}">
        <a th:text="首页" th:href="@{/pageGetAll(pageNum=1)}"></a>
        <a th:text="上一页" th:href="@{/pageGetAll(pageNum=${pageInfo.prePage})}"></a>
    </div>
    <div th:if="!${pageInfo.isLastPage}">
        <a th:text="尾页" th:href="@{/pageGetAll(pageNum=${pageInfo.pages})}"></a>
        <a th:text="下一页" th:href="@{/pageGetAll(pageNum=${pageInfo.nextPage})}"></a>
    </div>
</body>
</html>
```

## 异常处理

### 异常页面

在templates中新建一个`error`目录，在其中新建对应的错误页面。如404错误： 404.html
或者使用通配的名称，如400系列错误：4XX.html

![](img/Snipaste_2023-11-06_15-40-53.png)

这样配置后，项目出现对应的错误，springboot会自动去templates中找到对应页面显示。

### 局部异常处理

在Controller中添加异常处理方法，在方法上添加`@ExceptionHandler`注解，指定需要捕获的异常类型，并在方法中进行异常处理。

```java
@ExceptionHandler(Exception.class)   //表示捕获该controller中的所有异常
@ResponseBody
public String catchException(){
    System.out.println("进入异常捕获方法，。。。");   //异常处理
    return "500异常";   //可以进行页面跳转等操作
}
```
### 全局异常处理

新建一个异常处理类，使用`@ControllerAdvice`注解标注。并在方法中使用`@ExceptionHandler`注解，指定需要捕获的异常类型

```java
@ControllerAdvice
public class ExceptionCatcher {
    @ExceptionHandler(Exception.class)
    public String showExcep(){
        /* 进行异常处理 */
        return "/error/500";
    }
}
```

## 拦截器

### 使用拦截器步骤

1. 创建自定义拦截器，实现HandlerInterceptor接口并重写其中的 `preHandle`，`postHandle`，`afterCompletion` 方法
```java
@Component
public class MyInteceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("进入springboot拦截器");
        return false;
    }
}
```

2. 新建拦截器的配置类，配置拦截路径和放行路径

```java
@Configuration
public class MyConfig implements WebMvcConfigurer {
    
    @Resource
    private MyInteceptor myInteceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(myInteceptor).addPathPatterns("/**").excludePathPatterns("/getAll");
        //表示拦截所有路径，放行`/getAll`路径
    }
}
```