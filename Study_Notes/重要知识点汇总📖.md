# [[9-集合#^f41718|HashSet]]实现原理
HashSet采用哈希表作为存储结构。
### 哈希表的特点：
1. **快速查找或插入**
	哈希表的主要优点是能够在平均情况下以常数时间复杂度（O(1)）进行查找、插入和删除操作，使得HashSet在处理大量数据时具有高效的性能。
2. **无序性**
	哈希表不保证元素的顺序，因此HashSet中的元素是无序的，与插入的顺序无关。
3. **唯一性**
	HashSet中不允许存储重复的元素，每个元素只能出现一次。这是由哈希表的特性所决定的，每个键（元素）只会对应一个哈希值。
### 哈希表的实现原理：
#### 1. 哈希函数
哈希表依赖于哈希函数。哈希函数可以将对象映射为一个整型的哈希值。Object类中的`hashCode()`方法就是用于返回对象的哈希值的。这个哈希值是通过对象的内容得出来的，对于不同的对象，其哈希值应当尽量不同
#### 2. 哈希冲突
由于哈希算法的缺陷，哈希函数的映射是有限的，而对象的状态的无限的。因此***哈希冲突不可避免***。解决哈希冲突的方法通常有**开放寻址法**和**链表法**。HashSet采用**链表法**来避免哈希冲突：每个**桶**`bucket`不仅可以存储元素，还可以存储链表或者其他数据结构。当出现哈希冲突时，将相同哈希值的元素放在同一个桶中。
#### 3. equals()方法
`equals()`方法用于辅助`hashCode()`方法，保证哈希表能够准确无误的找到想要的值。当哈希表通过哈希函数的计算找到目标元素的地址时，还需要通过`equals()`方法对比该地址 (桶) 中的元素内容，以确保找到正确的目标元素。

---
# 列表新增元素的底层原理
`void add(int index,E element)`
先看源码：
```java
public void add(int index, E element) {  
    rangeCheckForAdd(index);  
    modCount++;  
    final int s;  
    Object[] elementData;  
    if ((s = size) == (elementData = this.elementData).length)  
        elementData = grow();  
    System.arraycopy(elementData, index,  
                     elementData, index + 1,  
                     s - index);  
    elementData[index] = element;  
    size = s + 1;  
}
```
这里介绍一下`System.arraycopy()`方法，该方法的五个参数含义：
1. `Object src`   源数组
2. `int srcPos`  源数组中的起始位置
3. `Object dest`  目标数组
4. `int destPos`  目标数组中的起始位置
5. `int length`  要复制的元素数量
以上`add`操作用画图抽象一下：
![[add(int index,E element).png]]
我们假设`index=5`，数组对象`elementData`长度为10。那么上述copy操作的源数组和目的数组是同一个，也就是说他在自身操作数据。`src = 5`  ,`destPos = 5+1`  ,`length=10-5`。所以该函数将索引5-9的数据复制到了索引6-10的位置上，此时索引5的位置上元素值没有改变。然后通过`elementData[index] = element; `语句将要插入的值赋给索引为5的位置，添加完成后数组元素数量+1。

---
# 简述List和Set的区别
#### Set接口：无序，唯一
实现类：
	HashSet ：基于哈希表，不保证顺序
	LinkedHashSet ： 在HashSet的基础上维护元素插入顺序
	TreeSet ：基于红黑树，按照自然顺序或自定义比较器 (内部比较器实现`Comparable`接口和外部比较器实现`Comparator`接口) 顺序排序。
>向Set集合中存入对象数据时，该对象类应当重写`equals()`和`hashCode()`方法，以确保`Set`的正常运作
#### List接口：有序，不唯一
实现类：
	ArrayList ：基于动态数组，支持随机访问，插入和删除效率低下
	LinkedList ：基于双向链表，插入和删除效率高，但是随机访问效率低下
	Vector ：类似于ArrayList，JDK早期版本的列表接口实现类。线程安全，但是效率低下。已经被弃用

---

# 迭代器
迭代器专为集合而生，专门实现集合遍历。该接口右三个方法，分别是`hasNext()` , `next()`, `remove()`.
- `boolean hashNext()` : 检查是否还有下一个元素可以迭代。
- `E next()`: 获取下一个元素，并将迭代器的状态前移。
- `void remove()`: 从集合中安全地移除上一个 `next` 方法返回的元素。这是迭代器提供的唯一一种可以在遍历中修改集合的方式。
#### 迭代器正向遍历

```java
	Iterator iterator = list.iterator();  
	while (iterator.hasNext()){   
		iterator.next();
	}
```
#### 迭代器反向遍历
要在 Java 中实现反向遍历（从后往前遍历）集合，可以使用 `ListIterator` 接口。`ListIterator` 是 `Iterator` 的一个子接口，它提供了一些额外的方法，使你能够在列表中双向移动和操作元素。
-  `boolean hasNext()`: 检查是否还有下一个元素可以迭代（从前往后）。
-  `E next()`: 获取下一个元素，并将迭代器的状态前移。
- `boolean hasPrevious()`: 检查是否还有上一个元素可以迭代（从后往前）。
-  `E previous()`: 获取上一个元素，并将迭代器的状态后移。
-  `int nextIndex()`: 返回下一个元素的索引。
- `int previousIndex()`: 返回上一个元素的索引。
-  `void add(E e)`: 在迭代器的当前位置添加一个元素。
- `void set(E e)`: 用指定的元素替换上一个 `next` 或 `previous` 方法返回的元素。
-  `void remove()`: 移除上一个 `next` 或 `previous` 方法返回的元素。

```java
	ListIterator<String> listIterator = list.listIterator(list.size()); //从最后一个元素开始
	while (listIterator.hasPrevious()){
		listIterator.previous();
	}
```

### 使用迭代器移除集合中的元素
`Iterator` 提供的 `remove` 方法可以安全地移除元素，是因为迭代器在遍历集合的过程中维护了一个状态，知道当前元素的位置，从而能够在不破坏遍历的一致性的情况下进行元素的移除。

底层原理如下：
1. 当你通过迭代器的 `next` 方法获取下一个元素时，迭代器会记录当前元素的索引位置以及其他相关信息。
2. 当你调用迭代器的 `remove` 方法时，迭代器会根据记录的位置信息，将对应的元素从底层的数据结构（例如列表）中移除。
3. 迭代器还会更新内部的状态，以确保它继续从正确的位置继续遍历，而不会遗漏或重复元素。

这种方式可以确保在迭代过程中进行元素的移除而不会破坏迭代的状态。这是因为迭代器与底层集合的结构交互得到了控制，从而保证了一致性。

# 使用BufferedInputStream的readAllBytes方法代替缓冲数组
	方法介绍：`byte[] readAllBytes()`
此方法从输入流中读取**所有**剩余字节, 该方法会引发线程阻塞，直到读取完所有的剩余字节并检测到字节流关闭，或抛出异常，此方法才会退出。
### 对比使用readAllBytes方法和使用一般缓冲数组
使用readAllBytes方法：
```java
byte[] bytes = bis.readAllBytes();  //输入流读数据
bos.write(bytes);   //输出流写数据
bos.close();  
bis.close();
```
使用一般缓冲数组：
```java
byte[] bytes = new byte[1024 * 8];   //8KB缓冲数组
int len;  
while ((len=bis.read(bytes))!=-1){     //进入循环
	bos.write(bytes, 0, len);   //将缓冲数组中的数据全部写入输出流
}  
bos.close();    //关流
bis.close();
```
`readAllBytes()`方法使得代码更加简洁。***但是请注意，该方法是JDK9加入的方法。***
# 反射面试题
### 问题一：创建Person对象，以后用new Person()创建还是用反射创建？
通常情况下，使用 `new Person()` 来创建对象是一种更常见和直观的方法。这是因为它是面向对象编程的基本原则之一，也是大多数编程语言的主流做法，包括Java、C#、Python等。通过直接调用类的构造函数来创建对象，不仅代码简单明了，而且易于理解和维护。

而使用反射来创建对象则是一种更加灵活但也更加复杂的方式。反射允许你在运行时动态地获取和操作类的信息，包括构造函数、方法和字段等。尽管反射在某些情况下很有用，比如在框架、库和一些高级应用中，但它也会带来性能损失和代码可读性下降等问题。此外，使用反射创建对象还可能导致编译器无法检测到的错误，增加了调试的难度。

因此，一般情况下推荐使用 `new Person()` 这种常规的方式来创建对象，而将反射保留给特殊情况或者需要动态处理类信息的情况下使用。
### 问题二：反射是否破坏了面向对象的封装性？
反射本质上可以让你绕过编程语言提供的封装性和访问限制机制，直接访问和修改类的私有成员，比如私有字段、方法等。从这个角度来看，反射可能会破坏面向对象编程的封装性原则，因为它允许代码在运行时绕过了编译时的访问控制规则。

然而，是否认为反射会完全破坏封装性是一个有争议的问题。封装性是面向对象编程的一个重要原则，它帮助我们隐藏实现细节，提供更清晰的接.口，并降低代码耦合度。使用反射可能导致代码更加脆弱，容易受到变化的影响，而且可能降低代码的可维护性。

因此，虽然反射可以突破封装性，但在使用时需要慎重考虑。在大多数情况下，遵循封装性原则并通过类的公共接口进行操作是更好的做法，除非特殊情况需要使用反射。总的来说，反射是一把双刃剑，可以带来便利性，但也要考虑其可能带来的后果。

# 数据库面试题
### 什么是索引下推，回表，索引覆盖？
要想理解这个问题，先了解一下mysql数据库的架构：
![Alt text](img/Snipaste_2023-09-04_13-00-46.png)
1. 索引下推 (index pushdown)
	索引下推是一种数据查询优化技术，它允许数据库系统在查询时尽可能多地使用索引来过滤数据，从而减少需要扫描的表格行数，提高查询性能。通常，查询会包含一个 WHERE 子句，用于筛选满足特定条件的行。索引下推的思想是，数据库查询优化器会尽量将这些筛选条件应用到索引上，以减少实际访问表格数据的需求。这可以通过将筛选条件直接应用于索引上来实现。
2. 回表 (table lookup)
	回表是指当数据库查询优化器使用了索引来找到满足条件的行后，仍然需要回到原始表格（通常是主表格）上执行进一步的查询操作。这是因为索引通常只包含了部分数据列或者索引键，而不是整个行的数据。当查询需要访问索引中没有的其他列数据时，就需要进行回表操作。回表操作会增加查询的成本，因此索引覆盖可以帮助减少回表的需求。
3. 索引覆盖 (index covering)
	索引覆盖是一种查询优化技术，它通过确保索引包含了查询中需要的所有列，从而避免回表操作。当一个索引能够满足查询的所有需求，包括筛选条件和选择的列，就称为索引覆盖。索引覆盖可以显著提高查询性能，因为它减少了回表操作，减少了对原始表格的访问，从而减少了查询的开销。
### 为什么脏读能读到事务未提交的数据？
目前主流的关系型数据库，如mysql, oracle等都是基于文件系统进行数据存储的，即数据是持久化到文件系统的。但基于文件系统的随机IO是非常低效的，故数据库都会引入内存池，完成对磁盘数据的缓存，提高性能。
内存池是对所有事务共享的。所谓的未提交，指的是事务未提交到物理文件中，但是数据已经存储到了共享内存中。
当事务a和事务b同时访问一行数据，事务b从数据库读到了事务a未提交的数据，但是事务a进行了回滚，就会导致事务b读到的数据和最终存储空间中的数据不一致的情况，这就是脏读的过程。

### innoDB的优点
1. **事务支持**：InnoDB支持ACID（原子性、一致性、隔离性和持久性）事务属性，这使得它非常适合处理需要数据完整性和可靠性的应用程序，如金融系统或在线交易处理（OLTP）应用。

2. **行级锁定**：InnoDB使用行级锁定，而不是表级锁定。这意味着多个事务可以同时修改表中不同的行，而不会相互阻塞，从而提高了并发性能。

3. **外键约束**：InnoDB支持外键约束，这是确保数据完整性的关键特性。您可以定义外键关系，以保持数据的引用完整性，这对于建立复杂的数据模型非常有用。

4. **崩溃恢复**：InnoDB具有崩溃恢复机制，可以在数据库发生崩溃或非正常关闭时自动恢复数据一致性。这有助于减少数据丢失和损坏的风险。

5. **自动增加列**：InnoDB支持自动增加列，使得插入新记录时可以轻松地为主键生成唯一值。
    
6. **热备份和恢复**：InnoDB支持在线热备份，这意味着您可以在不中断应用程序运行的情况下备份数据库。此外，它支持部分恢复，可以快速还原部分数据，而不需要完全恢复整个数据库。

7. **高并发性能**：由于InnoDB使用行级锁定，它在高并发环境中表现出色。这使得它非常适合需要大量并发读写操作的应用程序。

8. **支持全文搜索**：InnoDB支持全文搜索功能，使得您可以执行复杂的文本搜索操作。

# 数据结构补充
### 二叉树的遍历代码实现
二叉树结构可以大致分为根节点(D)，左子节点(L)，右子节点(R)
二叉树的遍历有前序遍历，中序遍历，后序遍历，层次遍历
在代码实现之前，我们先来定义一个二叉树
```java
class TreeNode {
    int val;
    TreeNode left;  //左节点
    TreeNode right;  //右节点

    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```
1. 前序遍历DLR
	就是按照根节点，左子节点，右子节点的顺序，递归地遍历树

![Alt text](img/DLR.png)

	👆前序遍历
	代码实现：
```java
void preorderTraversal(TreeNode root) {
    if (root == null) {
        return;
    }
    System.out.print(root.val + " ");
    preorderTraversal(root.left);
    preorderTraversal(root.right);
}
```
2. 中序遍历LDR
	就是按照左子节点，根节点，右子节点的顺序，递归地遍历树

![Alt text](img/LDR.png)

	👆中序遍历
	代码实现：
```java
void inorderTraversal(TreeNode root) {
    if (root == null) {
        return;
    }
    inorderTraversal(root.left);
    System.out.print(root.val + " ");
    inorderTraversal(root.right);
}
```
3. 后序遍历LRD
	就是按照左子节点，右子节点，根节点的顺序，递归地遍历树
	
![Alt text](img/LRD.png)

	👆后序遍历
	代码实现：
```java
void postorderTraversal(TreeNode root) {
    if (root == null) {
        return;
    }
    postorderTraversal(root.left);
    postorderTraversal(root.right);
    System.out.print(root.val + " ");
}
```

# 网络编程
## BIO, NIO , AIO
[5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/73361428)
[JAVA BIO与NIO、AIO的区别(容易理解) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/419345478)
[别挠头了！我教你什么是BIO，NIO，AIO - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/620846163#:~:text=%E6%88%91%E6%95%99%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AFBIO%EF%BC%8CNIO%EF%BC%8CAIO%201%201.%20BIO%EF%BC%9A%20Blocking%20IO%20%E5%8D%B3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%BC%8FIO%202,IO%20%E5%8D%B3%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%203%203.%20AIO%EF%BC%9A%20Asynchronous%20IO%20%E5%8D%B3%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%88%E5%B8%B8%E8%A7%81%E4%BD%86%E6%98%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E8%88%AC%E4%B8%8D%E7%94%A8%EF%BC%89)


# 雪花算法如何解决时钟回拨问题？
[雪花算法的详解及时间回拨解决方案 - 白露~ - 博客园 (cnblogs.com)](https://www.cnblogs.com/shoshana-kong/p/17319231.html)
[面试题：雪花算法（SnowFlake）如何解决时钟回拨问题_雪花算法时间回拨处理_XP-Code的博客-CSDN博客](https://blog.csdn.net/Wisimer/article/details/115584462)
雪花算法是twitter公司开源的，用于在分布式系统中生成唯一的id标识的算法。
该id包含
	1bit的符号位，
	41bit的时间戳，表示特定时间到当前时间的毫秒数，支持约69年的运行期限
	10bit的机器码，
	12bit的序列号
雪花算法允许每台机器在1ms内生成4096个唯一id
雪花算法的时钟回拨问题提供以下几种思路来解决：
1. 异常处理
	当系统检测到时钟回拨时，抛出异常，系统终止运行。
	这种做法虽然不会导致id重复，但是会影响系统的可用性
2. 等待时钟回复
	系统检测到时钟回拨后，让线程睡眠等待。当系统时间回复，重新开始运作。
3. 生成备用id
	当时钟回拨发生后，通过其他机制来生成备用id。例如引用一个新的时钟系统等。这种方式通常需要人工兜底来确保系统的正确运行。
4. 采用日志系统
	记录过去一段时间内 **每台机器在当前毫秒内产生的id的最大值** 。当发生时钟回拨问题时，只需要从该 **最大值** 开始继续递增即可

# 单例模式的五种实现方式
单例模式（[Singleton](https://so.csdn.net/so/search?q=Singleton&spm=1001.2101.3001.7020) Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

注意：

1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例。
[单例模式的五种实现方式（饿汉式、懒汉式、DCL懒汉式、静态内部类式、枚举单例）、优缺点比较_Marvellous丶的博客-CSDN博客](https://blog.csdn.net/baolingye/article/details/101106783)
[懒汉式单例演进到DCL懒汉式 深度全面解析_dcl 演变过程-CSDN博客](https://blog.csdn.net/weixin_47196090/article/details/115033947)

# HashMap多线程死循环问题

hashMap的死循环问题只发生在JDK7之前，从JDK8开始，hashMap的链式寻址改为了尾插法，解决了链表死循环的问题。

hashMap死循环的主要原因是由hashMap的底层实现决定的。因为hashMap在扩容时，采用的是**头插法**。

![Alt text](img/Snipaste_2023-09-07_20-02-33.png)

假如现在hashMap需要扩容，hashMap会创一个新的hashMap，然后使用头插法将旧hashMap中的数据插入新hashMap中。此时新hashMap中一个桶内的数据就会变成反序的。

![Alt text](img/Snipaste_2023-09-07_20-06-01.png)

此时有两个线程，线程1正在准备遍历桶中的元素，此时他的头指针指向A的引用。`next()`指向B的引用。 与此同时，线程2向hashMap中添加了一个元素，触发了hashMap扩容机制，由于采用头插法，现在，新的hashMap中桶中的元素顺序反过来了。此时线程1的头指针仍然为A，`next()`指向B。开始遍历，走到B中去，但是在这个新的hashMap中，B的`next()`又是A，于是他又走到A中去，又由于在扩容前，A的`next()`是B，这样 线程1 就会陷入死循环，在AB间反复横跳，从而导致计算机CPU占用暴涨，系统发生故障。

![Alt text](img/Snipaste_2023-09-07_20-13-42.png)

## 如何解决？
1. 使用线程安全的`ConcurrentHashMap`代替`HashMap`，推荐
2. 使用`HashTable`代替`HashMap`，但是性能低
3. 使用`synchronized` 或 `lock` 加锁，会影响性能

>在JDK8之后，HashMap的插入改为了尾插法，此问题也是得到了解决。

# 工厂模式
