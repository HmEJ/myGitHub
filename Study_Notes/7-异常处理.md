#8-7
### 为什么要学习异常处理？
1. 根本原因：确保运行中的程序不会终止
2. 在之前的学习中，处理异常情况通常使用`if选择结构`来解决。而随着学习的深入，程序也越来越复杂，我们无法考虑到全部的异常情况，因此需要java的异常处理机制来帮助我们更加便捷地处理异常。


---
### 异常处理的使用
- `break`和`continue`流程控制语句不可以使用在`try-catch`结构中
- `return`也不能阻止`finally`语句的执行。程序会先执行`finally`，之后再执行`return`
```
try{
	被监控的语句
}catch(异常类1 引用名){
	异常处理1...
}catch(异常类2 引用名){
	异常处理2...
}finally{
	最终执行语句  //无论如何都会执行(无敌)
}
=================================================
try块中可以没有catch或finally.但是二者不可以同时不存在
try{
	...         //无catch 须有finally
}finally{
	...
}
------
try{
	...
}catch{
	...        //无finally 须有catch
}
但是catch和finally不能脱离try单独存在
```
#### 抛出异常
`throws` 和`throw`
区别： ^0b3408
1. `throws`用于方法头，表示的只是异常的声明，而`throw`用于方法内部，抛出的是*异常对象*
2. `throws`可以一次性抛出多个异常，而`throw`只能抛一个
3. `throws`抛出异常时，它的上级（调用者）也要申明抛出异常或者捕获，不然编译报错。而`throw`的话，可以不申明或不捕获（这是非常不负责任的方式）但编译器不会报错。            

>一个方法中有`throw`就一定有`throws`，有`throws`不一定有`throw`

使用`System.exit();`可以关闭java虚拟机，让`finally`中的代码不执行。
##### Q&A 什么情况下，try-catch后面的代码不执行
1. `throw`抛出异常
2. `catch`中没有正常的进行捕获
3. 在`try`中遇到`return`





---
### 异常的分类

^4333dc

1. 检查时异常 
	不处理程序无法启动
2. 运行时异常
	不处理也不影响程序的运行

---

### 自定义异常
有时候为了提醒调用者，虽然代码本身没有错误，我们还是得手动抛出错误。
因为代码本身没有错误，所以没有一个相匹配的错误类型给我们用，所以只能自定义异常。
#### 创建自定义异常类
[[6-面向对象#^8dccc9|继承]]其他异常即可