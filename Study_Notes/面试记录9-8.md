# 面试记录
### 我看你学过软件工程，那你了解白盒测试和黑盒测试吗？
是的面试官，软件工程是我大学的主修课程之一。白盒测试和黑盒测试我是了解的。

白盒测试一般由代码编写人员在写代码的过程中就给做完了，他是对代码的一种调试。Java中提供的Junit测试类就是用来进行白盒测试的。

黑盒测试一般需要专业的测试人员，通过一些方法设计出相关的**测试用例**，对产品最终的体验进行测试。因为无法洞察代码的内部结构，就像个黑匣子一样，因此得名黑盒测试。

>回答的可以

### 谈谈Java的三大通讯模型，BIO,NIO,AIO？
好的面试官。Java三大通讯模型，第一个BIO，

BIO是同步阻塞IO，它实现原理就是通过阻塞IO来实现。阻塞IO就是应用程序**发起系统调用**后，如果OS内核没有资源可以分配，该进程就会啥也不干，一直等下去，处于一个阻塞状态。直到OS内核有资源可以分配了，他才会成功获取到数据。这种模型的缺点就是他效率低下。

NIO是同步非阻塞IO，应用程序在发起系统调用请求后，如果OS内核没资源给分配，就会返回一个**标识符**给应用程序。应用程序收到这个标识符后会再次发送调用请求。这样，该应用程序会轮询的向OS发送调用请求，直到OS有资源给分配，成功执行了指令。这种模型缺点就是他非常消耗CPU资源，对系统性能要求高。

AIO是异步IO，应用程序给OS内核抛出一个请求后，就不管了，他去管别的事儿了。OS内核成功执行后会通知该应用程序，那应用程序就能一次性直接收到结果。这种模型适合高并发的场景。

>回答的有点偏了，说的貌似是阻塞IO,非阻塞IO和异步IO的原理，而不是Java BIO,NIO和AIO。

>关键点：
Java BIO服务器实现模式是一个连接一个线程，即客户端有链接请求时，服务器就需要启动一个线程进行处理。如果连接不做实事，那么会造成不必要的系统开销。

>Java NIO服务器实现模式是一个线程处理多个连接。即客户端发送的连接都会注册到**多路复用器**上,多路复用器轮询连接，有IO请求就会处理。

>Java AIO服务器实现模式是一个有效请求，一个线程。客户端的IO都是由OS**先完成了再通知服务器去启动线程进行处理**。一般适用于连接数较多并且连接时间较长的应用

### 了解代理模式吗？
了解一点。代理模式就相当于找了第三方进行一个代理，他是一种控制反转，将一个类访问另一个类的权力反转给第三方。这个代理类可以控制一个类访问另一个类的权限，可以决定这个类能访问什么，不能访问什么。以上就是我的理解。

>说的有点问题。代理模式和控制反转是两个不同的概念：

>代理模式是一种结构性设计模式，其主要目的是**控制对对象的访问(这点说对了)**。代理模式通常涉及到两个角色，代理对象和真实对象。代理对象充当真是对象的门卫，它可以用来添加额外的控制，如延迟加载，缓存，权限控制等。代理模式有多种变体，如静态代理，动态代理等。静态代理是在编译时创建代理对象，动态代理则是在运行时创建代理对象。

>控制反转（IoC）是一种设计原则。他是将控制权从程序的主要逻辑中反转出去，一般通过**依赖注入(DI)** 实现。IoC目标是降低组件之间的耦合度，使应用程序易于维护和扩展。在IoC容器中，对象的创建和生命周期由容器负责。Spring框架就是一个典型的IoC容器。

### 适配器模式了解吗？
适配器模式是解决两个类接口不兼容的问题。当两个类的接口互不兼容，无法在一起工作，而我们又想让其在一个工作时，就需要一个适配器。举个具体的例子，我们有一个二相插头，但是插座是三相的，此时我们就需要一个二相转三相的适配器，来配合我们使用该插座。这个适配器类一般是继承一个类，实现另一个类的接口，然后在类中写一个操作逻辑。。

>回答的基本正确。最后一点说的，可以改进一下： 适配器类一般是**包装** ( *让旧的类作为适配器类的一个成员* ) 了不兼容接口的对象，并提供了一个与目标接口兼容的接口，从而实现了对象之间的协同工作。
以下是一个代码示例：
```java
// 旧的不兼容的类
class LegacyRectangle {
    public void display(int x1, int y1, int x2, int y2) {
        System.out.println("LegacyRectangle: (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");
    }
}
// 目标接口
interface Rectangle {
    void draw(int x, int y, int width, int height);
}
// 适配器类
class LegacyRectangleAdapter implements Rectangle {
    private LegacyRectangle legacyRectangle;

    public LegacyRectangleAdapter(LegacyRectangle legacyRectangle) {
        this.legacyRectangle = legacyRectangle;
    }

    @Override
    public void draw(int x, int y, int width, int height) {
        // 使用适配器将目标接口方法映射到旧类的方法
        int x1 = x;
        int y1 = y;
        int x2 = x + width;
        int y2 = y + height;
        legacyRectangle.display(x1, y1, x2, y2);
    }
}
```

### innoDB的底层存储结构是什么？
B+树。他是B树的一种优化。B树是一种多叉树，他的每个节点及存储关键字 ( 索引 ) 又存储数据。B+树在B树的基础上，使所有的数据都存放在叶子节点中。非叶子节点只存储关键字。这样就大大拓展了数据的存储量。

> 答的可以。
### B+树的优化在哪里？
我以上说的算是一种优化吧，其他的，我唔知啊

>B+树对B树的优化体现在以下几个方面：

>1. B+树更适合存储在外存储器中。因为B树的每个节点都包含关键字和数据，这样数据量增多后，树的高度增加，需要频繁的IO。相比之下，B+树只在叶子节点存放数据，IO次数显著减少，提高了磁盘访问效率。

>2. 顺序性。B+树的每个叶子节点通常包含了一个指向前一个节点的指针和指向后一个节点的指针。这种**双向链表**的结构使得B+树在执行**范围查询**时非常高效，因为它可以允许你从一个起始位置开始，按顺序遍历数据，而不需要回溯树的内部节点

>3. 稳定性。B+树数据都存放在叶子节点，非叶子节点数量较少，树的高度相对较低，所以查找，插入和删除的性能更加稳定。

### innoDB如何解决幻读？
innoDB采用多版本并发控制系统来解决幻读问题。MVCC的具体实现有以下三个点：

第一 ，版本号。每个事务，表中的每行数据都有一个自己的版本号。事务的每次执行，表中数据的每次变动都会改变这个版本号。

第二，快照读。数据库查询操作会根据事务开始时的版本号来获取数据，这样他能保证在读取数据时，获取的是事务开始前的数据，因此，再面临并发问题时，他并不会因为原表数据的更改而读到不一致的数据，有效解决了幻读问题。

第三，间隙锁。MVCC会对查询范围中不存在的数据行之间加锁，防止其他事务在这些间隙中插数据，从而避免幻读。
>回答的有点混乱。这个问题应该按照以下方式回答：

>innoDB是通过MVCC和next-key lock来解决幻读问题的。在当前读的情况下，通过next-key lock来解决。在快照读的情况下，通过MVCC来解决。

>这里说一下什么是快照读和当前读，以及next-key lock 间隙锁 和 记录锁

>快照读 只读取**事务启动时的数据快照**，而不受其他事务正在进行修改的影响。这意味着快照读会返回一个事务开始时就已经存在的数据版本。快照读一般用于RR隔离级别。

>当前读 是读取数据的最新版本。如果一个事务执行当前读，而另一个事务正在修改相同的数据，当前读就会来等待锁的释放。当前读一般用于串行化隔离级别。

> 记录锁 锁定单行数据 。间隙锁 锁定一个范围内**未被使用的数据** ( 这些数据称为**间隙** )。next-key lock 锁定一个范围，同时锁定记录本身，相当于间隙锁➕记录锁。这样当一个并发事务相进行修改时，就只能等待另一个事务释放锁。
 
### 事务的底层原理？
事务底层是通过日志来实现的。就是记录每行数据的变化和事务的id。当事务出现异常时，便于进行一个回滚操作。

> 说的正确，但是不够全面。

>事务想要实现的效果是什么？依照我的理解，无非就是可靠性和并发控制。
事务解决可靠性通过**日志文件系统**，事务解决并发控制问题通过MVCC和锁。

> 日志文件系统主要就是通过redo log(重做日志)和undo log(回滚日志)组成的。redo log用来实现事务的持久性。简单点说就是MySql为了提升性能并不会把每次修改都实时同步到磁盘中，而是会放到一个Buffer Pool中。然后使用后台线程去进行磁盘和内存的同步。但是为了避免停电，宕机导致的无法同步问题，引入了redo log系统。redo log由redo buffer 和 redo log组成。说白了就是mysql在把数据提交到 缓冲池 时，也会同时提交一份数据到redo buffer 中，这个redo buffer会和redo log磁盘文件实时同步。如果系统宕机，再次启动会从redo log中读取最新的数据，这样就保证了事务的持久性。

> undo log和redo log相反， undo log记录的是数据被修改前的信息，他保证的是事务的原子性。它用于在事务发生错误时进行回滚。

参考：
[知乎](https://zhuanlan.zhihu.com/p/515386351#:~:text=%E5%8E%9F%E5%AD%90%E6%80%A7%20%E6%98%AF%E6%8C%87%E4%BA%8B%E5%8A%A1%E4%B8%AD%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E6%88%90%E5%8A%9F%EF%BC%8C%E8%A6%81%E4%B9%88%E5%85%A8%E9%83%A8%E5%A4%B1%E8%B4%A5%E3%80%82%20%E4%B8%80%E8%87%B4%E6%80%A7%20%E6%98%AF%E6%8C%87%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%A7%8B%E7%BB%88%E5%A4%84%E4%BA%8E%E4%B8%80%E8%87%B4%E6%80%A7%E7%8A%B6%E6%80%81%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%82,%E9%9A%94%E7%A6%BB%E6%80%A7%20%E6%98%AF%E6%8C%87%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%89%8D%E7%9A%84%E4%B8%AD%E9%97%B4%E7%8A%B6%E6%80%81%E5%AF%B9%E5%85%B6%E4%BB%96%E4%BA%8B%E5%8A%A1%E4%B8%8D%E5%8F%AF%E8%A7%81%EF%BC%8C%E5%8D%B3%E7%9B%B8%E4%BA%92%E9%9A%94%E7%A6%BB%E3%80%82%20%E6%8C%81%E4%B9%85%E6%80%A7%20%E6%98%AF%E6%8C%87%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%AE%E6%94%B9%E6%B0%B8%E4%B9%85%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E3%80%82)、
[掘金](https://juejin.cn/post/7207707775772688442)

### 了解视图吗？

我了解视图。视图是表的快照，视图是基于sql语句的的一种虚拟表。如果你使用 `explain` 关键字对视图进行解析，你会发现视图中只有sql语句。而真实表解析后是一个完整的表结构。在一般情况下，修改视图并不会影响到原表。在某些情况下，修改视图会影响到原表。

>没说清楚到底是哪些情况🤨
>视图是从一个或多个表导出的虚拟表，其内容由查询定义。具有普通表的结构但是不存储数据。视图一般分为单表视图和多表视图

>单表视图一般用于查询或修改，会改变基本表的数据。多表视图一般用于查询，不会改变基本表的数据

参考：[CSDN](https://blog.csdn.net/m0_62617719/article/details/124313392)

## ArrayList和LinkedList的区别？
从效率上来说，ArrayList实现是数组。通过下标来进行索引，因此他的随机访问效率非常高。但是他插入和删除效率低下，因为每次插入和删除都需要改变表的结构。LinkedList是链表，他的查询效率较低，但是他的修改效率很高

>回答的不好。关于这俩的区别要从以下几点切入：

> 1. ArrayList实现是基于数组，LinkedList实现是基于**双向链表**
> 2. ArrayList的随机访问效率更高，LinkedList的插入删除效率更高
> 3. LinkedList通常比ArrayList更占内存。因为LinkedList节点除了存储数据，还存储了两个引用，一个指向前，一个指向后。 而ArrayList是在内存中开辟一块连续的空间，它存储方式更加紧凑，不需要额外的链表结构开销。

